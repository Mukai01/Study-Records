# 1. 初期設定

```sh
python3 -m django startproject blogproject
cd blogproject
python 3 manage.py startapp blogpost
touch blogpost/urls.py # ファイルを作成する
```

プロジェクトのurls.pyからアプリのurls.pyを呼び出すように書く。
```python
from django.contrib import admin
# includeを追加
from django.urls import path, include

# blogpost.urlsを追加
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blogpost.urls')),
]
```

settings.pyを変更する。

```python
# blogpostを追加
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blogpost.apps.BlogpostConfig'
]

~~~

# DIRSにtemplatesを追加
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

```

blogpostのurls.pyには、最低限のコードを書いておく。

```python
from django.contrib import admin
from django.urls import path

urlpatterns = [
    path('admin/', admin.site.urls),
]
```

# 2. model(データベースについて)
### models.pyについて理解する
データベースはDjangoではデフォルトでsqlite3が使われる。
setting.pyにて設定されている。

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

Djangoでデータベースを扱う際に使われるファイルがmodel.py。
```python
from django.db import models

# 以下のように追加する
class SampleModel(models.Model): # SampleMpdelは自由につけてよい
    title = models.CharField(max_length=100) # 最大100文字の文字列
    number = models.IntegerField() # 整数型のデータ
```

makemigrationsはデータを整理する設計図を作成するコマンド。
エラーがある場合に、データベースに反映させる前に教えてくれる役割がある。

```sh
python3 manage.py makemigrations

# 指定しないと全てのアプリに対して実行されるので、アプリを指定した方が良い
python3 manage.py makemigrations blogapp
```
これにより、0001_initial.pyが作成される。

### migrateコマンド
migrateコマンドはmakemigrationsコマンドによって作成されたファイルの内容に基づいて、  
データベースに変更を反映させるコマンド。

```sh
python3 manage.py migrate
```

この時のログを見ると、以下に対してもmigrateコマンドが実行されていることが分かる。
Djangoではこのように、基本的に必要とされるアプリを事前に作成してくれてる。

```python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'blogpost.apps.BlogpostConfig'
]
```

### 管理画面でユーザーテーブルを確認する
まずはターミナル上でユーザーを作成する。
```sh
python3 manage.py createsuperuser

# サーバーを起動する
python3 manage.py runserver
```

これらを実行して、127.0.0.1:8000/admin にアクセスして、ログインする。
Userテーブルはauthアプリで定義されたテーブル。AddUserで追加も可能。

アプリで作成したデータベーステーブルを管理画面に表示させるにはadmin.pyで設定が必要。
```python
from django.contrib import admin
# import 文を追加
from .models import SampleModel

# Modelを登録する
admin.site.register(SampleModel)
```

# 3. CRUDについて
Twitter, Youtube等はCRUDという共通の特徴を持っている。
C: Create
R: Read
U: Update
D: Delete

Djangoが用意したViewとCRUDの関係性は以下。
C: CreateView
R: ListView, DetailView
U: UpdateView
D: DeleteView

# 4. ListView
### urls.py

blogpostアプリのurls.pyを以下のように編集する。
```python
# 以下のコードを追加
from django.urls import path
from .views import BlogList

# requestにurlとあると、BlogListとして定義されたviewを呼び出す
urlpatterns = [
    path('list/', BlogList.as_view()),
]
```

### views.py
views.py にurls.pyで書いたBlogListを定義する。

```python
from django.shortcuts import render

# 以下のコードを追加
from django.views.generic import ListView
from .models import BlogModel

# BlogListがListViewを継承
class BlogList(ListView):
    template_name = 'list.html'
    model = BlogModel
```

### models.py
models.pyにデータベースを定義する。

```python
from django.db import models
# 左側がpythonの実装に使う表記、右が人間が見る表記
CATEGORY = (('business','ビジネス'),('life','生活'),('other','その他'))

# model.Modelを継承
class BlogModel(models.Model):
    title = models.CharField(max_length=100) 
    content = models.TextField() # 長いときはTextField
    postdate = models.DateField(auto_now_add=True) # ブログ記事が投稿された日付を自動で記録
    category = models.CharField(max_length=50, choices = CATEGORY) # choicesでドロップダウン
```
またadmin.pyに変更を加える

```python
from django.contrib import admin
# BlogModelを追加
from .models import SampleModel, BlogModel

admin.site.register(SampleModel)
# BlogModelを追加
admin.site.register(BlogModel)
```

```sh
# makemigrationsを実行
python3 manage.py makemigrations
# データベースを作成
python3 manage.py migrate
# サーバーを立ち上げる
python3 manage.py runserver
```
127.0.0.1:8000/admin にアクセスし、ログイン。
しかし、これでは管理画面でのデータのタイトルから中身が分かりにくい。  
models.pyに一部コードを追加する。
```python
from django.db import models
CATEGORY = (('business','ビジネス'),('life','生活'),('other','その他'))

class BlogModel(models.Model):
    title = models.CharField(max_length=100) 
    content = models.TextField()
    postdate = models.DateField(auto_now_add=True)
    category = models.CharField(max_length=50, choices = CATEGORY)

    # 以下を追加
    # __str__ はオブジェクトの文字列表現を返す
    # BlogModelというクラスから作成された個別のオブジェクトに、self.titleという文字列表現を与える
    # これによりtitleが表示されるようになる
    def __str__(self):
        return self.title
```

```sh
# サーバーを立ち上げる
python3 manage.py runserver
# 表示が変わっていることを確認する
```

### htmlファイルの作成
* {% %}: テンプレートタグ
* {{}} : テンプレート変数
```html
<!-- object_listの中にあるデータを一つずつ取り出し、itemの中に格納する -->
<!-- 今回はBlogModelの中身がobject_listに格納されている -->
{% for item in object_list %}
    <ul>
    <li>{{ item.title }}</li>
    <li>{{ item.content }}</li>
    <li>{{ item.postdate }}</li>
    <li>{{ item.category }}</li>
    </ul>
{% endfor %}
```

```sh
python3 manage.py runserver
```
http://127.0.0.1:8000/list　にアクセスする。
